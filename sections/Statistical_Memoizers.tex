To transfer this idea to probabilistic programming, we now introduce a language construct called a
\emph{statistical memoizer}.  Suppose we have a function $\ftt$ which can be evaluated 
but we wish to learn about the behavior of $\ftt$ using as
few evaluations as possible.  The statistical memoizer, which here we give the
name \gpmem, was motivated by this purpose.  It produces two outputs:
\[ \ftt \xrightarrow{\gpmem} (\ftt_\probe, \ftt_\emu). \]
The function $\ftt_\probe$ calls $\ftt$ and stores the output in a memo
table, just as traditional memoization does.  The function $\ftt_\emu$ is
an online statistical emulator which uses the memo table as its training
data.  A fully Bayesian emulator, modelling the true function $\ftt$ as a
random function $f \sim P(f)$, would satisfy
\[
\texttt{(}\ftt_\emu\ \xtt_1\ \ldots\ \xtt_k\texttt{)}
\sim
P\pn{
  f(\xtt_1), \ldots, f(\xtt_k)
  \mvert
  \text{$f(\xtt) = \texttt{(f x)}$ for each $\xtt$ in memo table}
}.
\]
Different implementations of the statistical memoizer can have
different prior distributions $P(f)$; in this paper, we deploy a Gaussian process
prior (implemented as \texttt{gpmem} below).  Note that we require the ability
to sample $\ftt_\emu$ jointly at multiple inputs because the values of
$f(\xtt_1),\ldots,f(\xtt_k)$ will in general be dependent.

In Venture, we initialize \gpmem\ as follows:

    \begin{lstlisting}
    assume K = make_squaredexp (sf, l)
    assume (f_compute f_emu) =  gpmem( f, K))
    \end{lstlisting}



Adding a single line to the program, such as
    \begin{lstlisting}
    infer mh( quote( parameters), one, 50),
    \end{lstlisting}
allows us perform Bayesian inference over the parameters \texttt{sf} and \text{l}. 
Such inference can be performed without the refactoring and elaboration needed if one
would describe the above declaratively as in traditional statistics notation. 
In contrast to traditional statistics notation, probabilistic programs are written
procedurally; reasoning declaratively about the dynamics of a fundamentally procedural inference
algorithm is often unwieldy due to the absence of programming constructs
such as loops and mutable state.

